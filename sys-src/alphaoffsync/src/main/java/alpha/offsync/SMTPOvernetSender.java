/**************************************************************************
 * alpha-Flow: distributed case files in form of active documents
 * (supporting knowledge-driven ad-hoc processes in healthcare)
 * ==============================================
 * Copyright (C) 2009-2012 by 
 *   - Christoph P. Neumann (http://www.chr15t0ph.de)
 **************************************************************************
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 **************************************************************************
 * $Id: SMTPOvernetSender.java 3786 2012-05-04 08:00:25Z uj32uvac $
 *************************************************************************/
package alpha.offsync;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.BlockingQueue;

import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import java.util.logging.Logger;


import alpha.model.AlphaCardDescriptor;
import alpha.model.Payload;
import alpha.model.apa.APAPayload;
import alpha.model.apa.Priority;
import alpha.model.cra.ContributorID;
import alpha.model.cra.EndpointID;
import alpha.model.cra.ObjectUnderConsideration;
import alpha.model.cra.Participant;
import alpha.model.docconfig.AlphadocConfig;
import alpha.model.identification.AlphaCardID;
import alpha.model.psa.AlphaCardRelationship;
import alpha.model.psa.PSAPayload;
import alpha.offsync.security.MailAuthenticator;
import alpha.overnet.OvernetSender;
import alpha.overnet.event.AddAlphaCardEvent;
import alpha.overnet.event.ChangeAlphaCardDescriptorEvent;
import alpha.overnet.event.ChangePayloadEvent;
import alpha.overnet.event.DeliveryAcknowledgement;
import alpha.overnet.event.ParallelJoinCallback;
import alpha.overnet.event.ParallelJoinSynchronisation;
import alpha.overnet.event.ParticipantJoinEvent;
import alpha.overnet.event.SequentialJoinCallback;
import alpha.overnet.event.SequentialJoinSynchronisation;
import alpha.overnet.event.TokenPropagation;
import alpha.overnet.security.SecurityUtility;
import alpha.util.HardwareAddress;
import alpha.util.StringWrapper;

/**
 * SMTP-based implementation of the {@link OvernetSender} interface.
 */
public class SMTPOvernetSender implements OvernetSender, Runnable {

	/** The local message counter of the current mail session. */
	private static int counter = 0;

	/** The Constant defaultTextBody. */
	private final static String defaultTextBody = "+++ This message has been auto-generated by alphaFlow +++ "
			+ "\n\n"
			+ "Do NOT delete this message manually and do NOT modify or add any IMAP flags!";

	/** The Constant LOGGER. */
	transient private static final Logger LOGGER = Logger
			.getLogger(SMTPOvernetSender.class.getName());

	/** The classes. */
	@SuppressWarnings({ "unchecked" })
	private final Class[] classes = new Class[] { AlphaCardDescriptor.class,
			AddAlphaCardEvent.class, ParticipantJoinEvent.class,
			ChangeAlphaCardDescriptorEvent.class, ChangePayloadEvent.class,
			Participant.class, AlphaCardID.class, AlphaCardRelationship.class,
			Payload.class, Priority.class, ContributorID.class,
			ObjectUnderConsideration.class, StringWrapper.class,
			SequentialJoinCallback.class, SequentialJoinSynchronisation.class,
			ParallelJoinCallback.class, ParallelJoinSynchronisation.class,
			APAPayload.class, PSAPayload.class, TokenPropagation.class, DeliveryAcknowledgement.class };

	/** The marshaller used for serializing attachments. */
	private final Marshaller marshaller;

	/**
	 * The properties containing the necessary information to connect to the
	 * specified SMTP server.
	 */
	private final Properties smtpProperties;

	/** The local {@link AlphadocConfig}. */
	private final AlphadocConfig config;

	/** The {@link Session} used for sending emails. */
	private final Session session;

	/**
	 * The {@link SecurityUtility} used for encrypting and signing outgoing
	 * messages.
	 */
	private final SecurityUtility secUtil;

	/** The authenticator used for logging into the SMTP server. */
	private final Authenticator authenticator;

	/** The local message queue. */
	private final BlockingQueue<MessageInformation> queue;

	/**
	 * Instantiates a new {@link SMTPOvernetSender}.
	 * 
	 * @param config
	 *            the local {@link AlphadocConfig}
	 * @param authenticator
	 *            the {@link Authenticator} containing the SMTP communication
	 *            credentials
	 * @param secUtil
	 *            the {@link SecurityUtility} for encrypting and signing
	 *            outgoing messages
	 * @param queue
	 *            the local message queue
	 */
	public SMTPOvernetSender(final AlphadocConfig config,
			final Authenticator authenticator, final SecurityUtility secUtil,
			final BlockingQueue<MessageInformation> queue) {
		this.config = config;
		this.authenticator = authenticator;
		this.smtpProperties = new MessagingHelper(this.config)
				.retrieveSmtpProperties((MailAuthenticator) this.authenticator);
		this.marshaller = this.initializeMarshaller();
		this.session = this.initializeMailSession();
		this.secUtil = secUtil;
		this.queue = queue;
	}

	/**
	 * Transforms an object into a serialized XML file for sending.
	 * 
	 * @param obj
	 *            the object to be sent
	 * @param attachment
	 *            the output file
	 */
	private void transformForSending(final Object obj, final File attachment) {
		try {
			SMTPOvernetSender.LOGGER
					.finer("Marshalling message payload object.");
			this.marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
					Boolean.TRUE);
			this.marshaller.marshal(obj, attachment);
		} catch (final JAXBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * Initializes the JAXB marshaller.
	 * 
	 * @return the initialized JAXB marshaller
	 */
	private Marshaller initializeMarshaller() {
		try {
			final JAXBContext jaxbCtx = JAXBContext.newInstance(this.classes,
					null);
			return jaxbCtx.createMarshaller();
		} catch (final JAXBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * Initializes the mail session.
	 * 
	 * @return the initialized mail session
	 */
	private Session initializeMailSession() {

		// Create new session with the supplied login credentials
		// NOTE: Never use getDefaultInstance(..) if the application is supposed
		// to send AND receive AT THE SAME TIME! Even if sending and receiving
		// takes place in DIFFERENT Threads!
		SMTPOvernetSender.LOGGER.info("Creating SMTP session");
		final Session session = Session.getInstance(this.smtpProperties,
				this.authenticator);
		// session.setDebug(true);
		SMTPOvernetSender.LOGGER.info("SMTP session created");

		return session;

	}

	// /**
	// * Retrieves SMTP properties.
	// *
	// * @return the properties containing the necessary information to connect
	// to the
	// * specified SMTP server
	// */
	// private Properties retrieveSmtpProperties() {
	//
	// MailAuthenticator auth = (MailAuthenticator) this.authenticator;
	//
	// Properties properties = new Properties();
	// properties.put("mail.smtp.host", auth.getSmtpHost());
	// properties.put("mail.smtp.socketFactory.port",
	// auth.getSmtpSocketFactoryPort());
	// if(auth.getSmtpSocketFactoryClass().length() > 0){
	// properties.put("mail.smtp.socketFactory.class",
	// auth.getSmtpSocketFactoryClass());
	// }
	//
	// properties.put("mail.smtp.auth", auth.getSmtpAuth());
	// properties.put("mail.smtp.port", auth.getSmtpPort());
	//
	// return properties;
	// }

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {

		while (true) {
			try {
				final MessageInformation mInfo = this.queue.take();
				this.sendUpdate(mInfo.getUpdates(), mInfo.getRecipients(),
						mInfo.getSubject(), mInfo.getContent(),
						mInfo.isEncrypt(), mInfo.isSign());
			} catch (final InterruptedException e) {
				SMTPOvernetSender.LOGGER
						.info("Interruption received. Sender is terminating.");
				break;
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see alpha.overnet.OvernetSender#sendUpdate(java.lang.Object,
	 * java.util.Set)
	 */
	@Override
	public boolean sendUpdate(final Object obj, final Set<EndpointID> nodeIDs) {

		final List<Object> updates = new ArrayList<Object>();
		updates.add(obj);

		this.sendUpdate(updates, nodeIDs, null, null, true, true);

		// if (nodeIDs.isEmpty()) {
		// return false;
		// }
		//
		// for (EndpointID recipient : nodeIDs) {
		// try {
		// // Create a new message object to carry the payload that will be
		// // sent
		// LOGGER.info("Creating message to be sent.");
		// Message message = new MimeMessage(session);
		//
		// // Add sender of the message
		// LOGGER.info("Setting message sender.");
		// message.setFrom(new
		// InternetAddress(config.getLocalParticipant().getNode().getEmailAddress()));
		//
		// // Add recipient of the message
		// LOGGER.info("Setting message recipient");
		// message.setRecipients(Message.RecipientType.TO,
		// collectRecipientMailAddresses(collectRecipientInformation(nodeIDs)));
		//
		// // Add the subject of the message
		// LOGGER.info("Setting message subject");
		// message.setSubject("[alphaFlow Update] "
		// + config.getMyEpisodeId()
		// + " "
		// + config.getLocalParticipant().getContributor()
		// .getActor()
		// + "@"
		// + HardwareAddress.getHardwareAddress()
		// + " "
		// + obj.getClass()
		// .toString()
		// .substring(
		// obj.getClass().toString()
		// .lastIndexOf(".") + 1));
		//
		// // Create a multipart which will contain the single pieces of
		// // the
		// // message
		// Multipart multipart = new MimeMultipart();
		//
		// // Create the bodypart which will contain the true content of
		// // the
		// // message
		// MimeBodyPart messageBodyPart = new MimeBodyPart();
		//
		// // Insert the text of the message
		// LOGGER.info("Setting message text body.");
		// counter++;
		// messageBodyPart.setText(counter + " : " + defaultTextBody);
		//
		// // Add the text part to the multipart
		// multipart.addBodyPart(messageBodyPart);
		//
		// // Create the attachment of the message as a temporary file
		// LOGGER.info("Setting message attachment.");
		// messageBodyPart = new MimeBodyPart();
		// // File attachment = new File("AlphaFlowAttachment.xml");
		// // final File attachment =
		// // File.createTempFile("alphaFlowUpdate-",".xml");
		// final File attachment = File.createTempFile("attachment-",
		// ".xml");
		// attachment.deleteOnExit();
		// transformForSending(obj, attachment);
		//
		// // Add the attachment part to the multipart
		// multipart.addBodyPart(messageBodyPart);
		//
		// // Set the multipart as the content of the message
		// message.setContent(multipart);
		//
		// // Sign and encrypt the message if a SecurityUtility has been
		// // supplied
		// if (secUtil != null) {
		// PipedInputStream in = new PipedInputStream();
		// final PipedOutputStream out = new PipedOutputStream(in);
		//
		// new Thread(new Runnable() {
		// public void run() {
		// try {
		// secUtil.sign(out, new FileInputStream(
		// attachment), config
		// .getLocalParticipant().getNode()
		// .getEmailAddress());
		// out.close();
		// } catch (IOException e) {
		// e.printStackTrace();
		// }
		// }
		// }).start();
		//
		// final File securedAttachment = new File("secured.xml");
		//
		// secUtil.encrypt(new FileOutputStream(securedAttachment),
		// in, collectRecipientInformation(nodeIDs));
		//
		// messageBodyPart.attachFile(securedAttachment);
		// } else {
		// messageBodyPart.attachFile(attachment);
		// }
		//
		// // Send the message to its destination(s)
		// LOGGER.info("Dispatching message to SMTP server for sending.");
		// Transport.send(message);
		// LOGGER.info("Message has been transmitted to the SMTP server.");
		//
		// } catch (AddressException e) {
		// LOGGER.info("Invalid email address");
		// e.printStackTrace();
		// } catch (MessagingException e) {
		// LOGGER.info("Message could not be sent.");
		// e.printStackTrace();
		// } catch (IOException e) {
		// LOGGER.info("Could not create temporary file for mail attachment");
		// e.printStackTrace();
		// }
		//
		// }

		return true;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see alpha.overnet.OvernetSender#sendUpdate(java.util.List,
	 * java.util.Set, java.lang.String, java.lang.String, boolean, boolean)
	 */
	@Override
	public boolean sendUpdate(final List<Object> objects,
			final Set<EndpointID> recipients, final String subject,
			final String messageContent, final boolean encrypt,
			final boolean sign) {

		SMTPOvernetSender.LOGGER.info("NEW SEND METHOD CALLED");
		if (recipients.isEmpty())
			return false;

		final String[] recipientInformation = this
				.collectRecipientInformation(recipients);
		final InternetAddress[] recipientMailAddresses = this
				.collectRecipientMailAddresses(recipientInformation);

		for (final String rec : recipientInformation) {
			SMTPOvernetSender.LOGGER.info("String:" + rec);
		}

		for (final InternetAddress addr : recipientMailAddresses) {
			SMTPOvernetSender.LOGGER.info("ADDR:" + addr.getAddress());
		}

		// for (EndpointID recipient : recipients) {

		try {

			// Create a new message object to carry the payload that
			// will be sent
			SMTPOvernetSender.LOGGER.info("Creating message to be sent.");
			final Message message = new MimeMessage(this.session);

			// Add sender of the message
			SMTPOvernetSender.LOGGER.info("Setting message sender.");
			message.setFrom(new InternetAddress(this.config
					.getLocalNodeID().getNode().getEmailAddress()));

			// Add recipient of the message
			SMTPOvernetSender.LOGGER.info("Setting message recipient");

			message.setRecipients(Message.RecipientType.TO,
					recipientMailAddresses);

			// Add the subject of the message
			SMTPOvernetSender.LOGGER.info("Setting message subject");
			if (subject != null) {
				message.setSubject(subject);
			} else {
				message.setSubject("[alphaFlow Update] "
						+ this.config.getMyEpisodeId()
						+ " "
						+ this.config.getLocalNodeID().getContributor()
								.getActor() + "@"
						+ HardwareAddress.getHardwareAddress());
				// + " "
				// + obj.getClass()
				// .toString()
				// .substring(
				// obj.getClass().toString()
				// .lastIndexOf(".") + 1));
			}
			// Create a multipart which will contain the single pieces
			// of the message
			final Multipart multipart = new MimeMultipart();

			// Create the bodypart which will contain the true content
			// of the message
			MimeBodyPart messageBodyPart = new MimeBodyPart();

			// Insert the text of the message
			SMTPOvernetSender.LOGGER.info("Setting message text body.");

			if (messageContent != null) {
				messageBodyPart.setText(messageContent);
			} else {
				SMTPOvernetSender.counter++;
				messageBodyPart.setText(SMTPOvernetSender.counter + " : "
						+ SMTPOvernetSender.defaultTextBody);
			}

			// Add the text part to the multipart
			multipart.addBodyPart(messageBodyPart);

			for (final Object obj : objects) {

				boolean encryptAttachment = encrypt;
				boolean signAttachment = sign;

				// Create the attachment of the message as a temporary file
				SMTPOvernetSender.LOGGER.info("Setting message attachment.");
				messageBodyPart = new MimeBodyPart();
				// File attachment = new File("AlphaFlowAttachment.xml");
				// final File attachment =
				// File.createTempFile("alphaFlowUpdate-",".xml");
				final File attachment;
				if (obj instanceof File) {
					attachment = (File) obj;
					if (attachment.getAbsolutePath().equals(
							new File(this.config.getHomePath()
									+ "/publicKeyRing.asc").getAbsolutePath())) {
						messageBodyPart
								.setDescription(MessageContentDescriptions.ALPHAFLOW_CRYPTOGRAPHY_METADATA
										.toString());
						encryptAttachment = false;
						signAttachment = false;
					}
				} else {
					messageBodyPart
							.setDescription(MessageContentDescriptions.ALPHAFLOW_PROCESS_INFORMATION
									.toString());
					attachment = File.createTempFile("attachment-", ".xml");
					attachment.deleteOnExit();
					this.transformForSending(obj, attachment);
				}

				// Sign and encrypt the message if a SecurityUtility has
				// been supplied
				if ((this.secUtil != null)
						&& (encryptAttachment && signAttachment)) {
					final PipedInputStream in = new PipedInputStream();
					final PipedOutputStream out = new PipedOutputStream(in);

					new Thread(new Runnable() {
						@Override
						public void run() {
							try {
								SMTPOvernetSender.this.secUtil.sign(out,
										new FileInputStream(attachment),
										SMTPOvernetSender.this.config
												.getLocalNodeID()
												.getNode().getEmailAddress());
								out.close();
							} catch (final IOException e) {
								e.printStackTrace();
							}
						}
					}).start();

					final File securedAttachment = File.createTempFile(
							"secure_attachment-", ".xml");
					securedAttachment.deleteOnExit();
					this.secUtil.encrypt(
							new FileOutputStream(securedAttachment), in,
							recipientInformation);

					messageBodyPart.attachFile(securedAttachment);
				} else {
					messageBodyPart.attachFile(attachment);
				}

				// Add the attachment part to the multipart
				multipart.addBodyPart(messageBodyPart);
			}

			// Set the multipart as the content of the message
			message.setContent(multipart);

			// Send the message to its destination(s)
			SMTPOvernetSender.LOGGER
					.info("Dispatching message to SMTP server for sending.");
			Transport.send(message);
			SMTPOvernetSender.LOGGER
					.info("Message has been transmitted to the SMTP server.");

		} catch (final AddressException e) {
			SMTPOvernetSender.LOGGER.info("Invalid email address");
			e.printStackTrace();
		} catch (final MessagingException e) {
			SMTPOvernetSender.LOGGER.info("Message could not be sent.");
			e.printStackTrace();
		} catch (final IOException e) {
			SMTPOvernetSender.LOGGER
					.info("Could not create temporary file for mail attachment");
			e.printStackTrace();
		}

		// }

		return true;

	}

	/**
	 * Collects recipients information from the supplied {@link Set} of.
	 * 
	 * @param recipients
	 *            the {@link EndpointID}s
	 * @return the collected recipient information {@link EndpointID}s.
	 */
	private String[] collectRecipientInformation(
			final Set<EndpointID> recipients) {

		final String[] recipientInformation = new String[recipients.size()];

		int i = 0;
		for (final EndpointID recipient : recipients) {
			recipientInformation[i] = recipient.getEmailAddress();
			i++;
		}

		return recipientInformation;
	}

	/**
	 * Collects the recipients mail addresses from the supplied recipient
	 * information.
	 * 
	 * @param recipientInformation
	 *            the recipient information
	 * @return the collected mail addresses
	 */
	private InternetAddress[] collectRecipientMailAddresses(
			final String[] recipientInformation) {

		final InternetAddress[] recipientMailAddresses = new InternetAddress[recipientInformation.length];

		for (int i = 0; i < recipientInformation.length; i++) {
			try {
				recipientMailAddresses[i] = (InternetAddress
						.parse(recipientInformation[i]))[0];
			} catch (final AddressException e) {
				e.printStackTrace();
			}
		}

		return recipientMailAddresses;
	}

}
